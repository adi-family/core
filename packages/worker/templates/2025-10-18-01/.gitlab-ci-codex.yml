stages:
  - prepare
  - execute
  - report

variables:
  WORKER_IMAGE: "oven/bun:latest"
  GIT_SUBMODULE_STRATEGY: none

workflow:
  rules:
    # Only run on API/pipeline triggers or when SYNC_ONLY is set
    - if: '$CI_PIPELINE_SOURCE == "api"'
    - if: '$CI_PIPELINE_SOURCE == "trigger"'
    - if: '$CI_PIPELINE_SOURCE == "pipeline"'
    - if: '$SYNC_ONLY == "true"'
    # Block all other automatic triggers (push, merge_request, etc.)
    - when: never

sync-only:
  stage: prepare
  image: $WORKER_IMAGE
  tags:
    - implementation
  script:
    - echo "Syncing workspace repositories only (SYNC_ONLY mode)"
    - echo "Installing git..."
    - apt-get update && apt-get install -y git
    - git config --global user.email "${GITLAB_USER_EMAIL:-ci@gitlab.com}"
    - git config --global user.name "${GITLAB_USER_NAME:-GitLab CI}"
    # Configure git credentials for pushing
    - |
      if [ -n "$WORKER_REPO_TOKEN" ]; then
        # Use worker repo token for pushing to this repository
        git config --global credential.helper store
        echo "https://oauth2:${WORKER_REPO_TOKEN}@gitlab.com" > ~/.git-credentials
        echo "✓ Worker repository credentials configured"
      fi
      if [ -n "$GITLAB_TOKEN" ]; then
        # Also add GITLAB_TOKEN for cloning workspace repositories
        echo "https://oauth2:${GITLAB_TOKEN}@gitlab.com" >> ~/.git-credentials
        echo "✓ Workspace credentials configured"
      fi
    - cd ../
    - chmod +x binaries/sync-workspaces
    - ./binaries/sync-workspaces
    - echo "✓ Submodules synced successfully"
    - if: '$SYNC_ONLY == "true"'

prepare:
  stage: prepare
  image: $WORKER_IMAGE
  tags:
    - implementation
  script:
    - echo "Installing dependencies"
    - echo "Installing git..."
    - apt-get update && apt-get install -y git
    - git config --global user.email "${GITLAB_USER_EMAIL:-ci@gitlab.com}"
    - git config --global user.name "${GITLAB_USER_NAME:-GitLab CI}"
    - echo "✓ Using pre-compiled binaries"
    - echo "SESSION_ID=$SESSION_ID"
    - echo "PIPELINE_EXECUTION_ID=$PIPELINE_EXECUTION_ID"
    - if: '$SYNC_ONLY == "true"'
      when: never
    - when: always

execute:
  stage: execute
  image: $WORKER_IMAGE
  tags:
    - implementation
  script:
    # Install git if not available
    - echo "Installing git..."
    - apt-get update && apt-get install -y git
    - git config --global user.email "${GITLAB_USER_EMAIL:-ci@gitlab.com}"
    - git config --global user.name "${GITLAB_USER_NAME:-GitLab CI}"


    # Clean up old results from previous runs
    - rm -rf results
    - echo "✓ Cleaned up old results directory"

    # Update status to 'running'
    - |
      curl -X PATCH "$API_BASE_URL/pipeline-executions/$PIPELINE_EXECUTION_ID" \
        -H "Authorization: Bearer $API_TOKEN" \
        -H "Content-Type: application/json" \
        -d '{"status":"running"}'

    # Run Codex pipeline (binary version)
    - chmod +x binaries/codex-pipeline
    - ./binaries/codex-pipeline

    # Capture exit code
    - EXIT_CODE=$?

    # Update status based on exit code
    - |
      if [ $EXIT_CODE -eq 0 ]; then
        curl -X PATCH "$API_BASE_URL/pipeline-executions/$PIPELINE_EXECUTION_ID" \
          -H "Authorization: Bearer $API_TOKEN" \
          -H "Content-Type: application/json" \
          -d '{"status":"success"}'
      else
        curl -X PATCH "$API_BASE_URL/pipeline-executions/$PIPELINE_EXECUTION_ID" \
          -H "Authorization: Bearer $API_TOKEN" \
          -H "Content-Type: application/json" \
          -d '{"status":"failed"}'
        exit $EXIT_CODE
      fi
  artifacts:
    paths:
      - results/
    expire_in: 7 days
  rules:
    - if: '$SYNC_ONLY == "true"'
      when: never
    - when: always

report:
  stage: report
  image: $WORKER_IMAGE
  tags:
    - implementation
  script:
    # Upload artifacts via our API (binary version)
    - chmod +x binaries/upload-results
    - ./binaries/upload-results
  dependencies:
    - execute
  rules:
    - if: '$SYNC_ONLY == "true"'
      when: never
    - when: always
